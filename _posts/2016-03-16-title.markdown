---
layout: post
title: write a function to take a list of time ranges and return a list of condensed ranges
date: 2016-03-16 02:09:00
description: code practice problem
---
Determine what times of day everybody is available for a meeting. Meetings are stored as objects of the Meeting class with integer variables startTime and endTime. The integers represent the number of 30-minute blocks past 9:00AM.

Example:
{% highlight java %}
//given Meeting objects
new Meeting(2, 4); // meeting from 10:00AM – 11:00AM
new Meeting(3, 5); // meeting from 10:30AM – 11:30AM

//store the Meeting objects in a List
[(2, 4), (3, 5)]

//return the condensed range of meeting times
//times not included are times where everybody is available
[(2, 5)]
{% endhighlight %}

Code Overview:
Since it is not assumed that the meeting times are in order, the list should first be sorted
according to the startTime of the meeting. Next declare a new List to store merged meeting times. Two meetings have overlapping times between them if the startTime of the first meeting is bigger than or equal to the endTime of the second meeting. When there is an overlap a new meeting is created with the startTime being the smaller of the two from the previous startTimes and the endTime being the bigger of the two from the previous endTimes.

{% highlight java %}
import java.util.*;

public class P4
{
  public static void main(String[] args)
  {
    //Meeting(startTime, endTime)
    Meeting firstMeeting = new Meeting(0,1); //9:00AM – 9:30AM
    Meeting secondMeeting = new Meeting(3,5); //10:30AM – 11:30AM
    Meeting thirdMeeting = new Meeting(2,7); //10:00AM – 12:30PM
    
    List<Meeting> meetings = new ArrayList<Meeting>();
    //adds Meeting objects to meetings list
    meetings.add(firstMeeting);
    meetings.add(secondMeeting);
    meetings.add(thirdMeeting);
    
    //sorts list according to start time of each list entry
    Collections.sort(meetings, new MeetingStartTimeComparator());
    
    //list for holding merged meeting times
    List<Meeting> mergedList = new ArrayList<Meeting>();
    //initialized mergedList with first element from list
    mergedList.add(meetings.get(0));
    
    //iterate throught list and merge overlapping meeting times
    for (int i = 0; i < meetings.size(); i++)
    {
      meetings.get(i);
      //holds the most recent entry into the mergedList list
      Meeting lastMergedMeeting = mergedList.get(mergedList.size() - 1);
      
      if (meetings.get(i).startTime <= lastMergedMeeting.endTime)
      {
        lastMergedMeeting.endTime = Math.max(lastMergedMeeting.endTime, 
            meetings.get(i).endTime);
      }
      
      //no overlap
      else
      {
        mergedList.add(meetings.get(i));
      }
    }
  }
}
{% endhighlight %}

{% highlight java %}
public class Meeting
{
  int startTime;
  int endTime;

  public Meeting(int startTime, int endTime)
  {
    // number of 30 min blocks past 9:00 am
    this.startTime = startTime;
    this.endTime = endTime;
  }

  //starttime getter
  public int getStartTime()
  {
    return startTime;
  }
  
  //endtime getter
  public int getEndTime()
  {
    return endTime;
  }
  
  public String toString()
  {
    return String.format("(%d, %d)", startTime, endTime);
  }
}
{% endhighlight %}


{% highlight java %}
import java.util.*;

//MeetingStartTimeComparator class implements Comparator interface
class MeetingStartTimeComparator implements Comparator<Meeting>
{
  public int compare(Meeting meeting1, Meeting meeting2)
  {
    return meeting1.getStartTime() - meeting2.getStartTime();
  }
}
{% endhighlight %}
