<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:content="http://purl.org/rss/1.0/modules/content/">
	<channel>
		<title>Konstantin Polyashenko</title>
		<description>
			
				Konstantin Polyashenko&#39;s personal site and blog.
			
		</description>
		<link>http://konopoly.github.io</link>
		<atom:link href="http://konopoly.github.io/articles/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>doing scheme the right way</title>
				
					<category>scheme></category>
				
					<category>racket></category>
				
					<category>recursion></category>
				
				<description>what is scheme
Scheme is a powerful functional programming language. At its core it is a very minimal language and very easy to impliment when
compared to other languages. This is good and bad at the same time. It is easy to get started programming in scheme but often times
programmers that are experienced in an OOP language can have trouble getting started. It requires a diffrent way of appoaching problems
when programming in scheme. This is a quick guide to give a short introduction to scheme programming as well as scheme best practices that should be used.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title></title>
					<link>http://files.konopoly.github.io/img/thumbnails/</link>
				</image>
				<content type="html">
					
						<b>Warning:</b> this post contains math blocks rendered with the
						<a href="http://www.mathjax.org/">MathJax</a> JavaScript library. If you're using an RSS reader or
						otherwise have Javascript disabled, none of them will display, so you should instead read this article at
						its <a href="http://konopoly.github.io/articles/power-set-algorithms">source</a>.
					
					<h1 id="what-is-scheme">what is scheme</h1>
<p>Scheme is a powerful functional programming language. At its core it is a very minimal language and very easy to impliment when
compared to other languages. This is good and bad at the same time. It is easy to get started programming in scheme but often times
programmers that are experienced in an OOP language can have trouble getting started. It requires a diffrent way of appoaching problems
when programming in scheme. This is a quick guide to give a short introduction to scheme programming as well as scheme best practices that should be used.</p>

<h2 id="scheme-ides">scheme IDEs</h2>
<p>There are several good options when looking for an enviroment for scheme developnment. The best by far would be Dr.Racket, easy to use with some pretty powerful features. The debugger of Dr.Racket is also easy to use but can make scheme programming so much easier. Second to Dr.Racket is Emacs. Compared to Dr.Racket Emacs has a steeper learning curve but it has some features that are not present in Dr.Racket. So for the advanced scheme programmer Emacs might be a good option, but for most scheme programmers Dr.Racket is the better choice.</p>

<hr />

<p><span id="note1"><a href="#link1">1</a></span>: (completely tangentially) whenever I mention set theory I can’t help but think of
the infamous <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">Principia Mathematica</a>: a staggering, three-volume
attempt to axiomatize all of mathematics, published by <a href="http://en.wikipedia.org/wiki/Bertrand_Russell">Bertrand
Russell</a> and <a href="http://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North
Whitehead</a> in 1910-‘13, that relied heavily on sets. It’s
notorious, amongst other things, for proving <script type="math/tex">1 + 1 = 2</script> in no less than 379 pages. Check it out.</p>
>
				</content>
				<pubDate>Wed, 04 Feb 2015 13:00:00 -0800</pubDate>
				<link>http://konopoly.github.io/articles/power-set-algorithms</link>
				<guid isPermaLink="true">http://konopoly.github.io/articles/power-set-algorithms</guid>
			</item>
		
			<item>
				<title>nand2tetris: a book review and recap</title>
				
					<category>book review></category>
				
					<category>computer engineering></category>
				
				<description>what is Nand2Tetris?
Nand2Tetris, or The Elements of Computing Systems, is a twelve-part course in
fundamental computer engineering that steps you through the creation of a computer from the ground up, starting with
NAND logic gates and ending with an operating system capable of running a complicated program like Tetris.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>The cover of Nand2Tetris.</title>
					<link>http://files.konopoly.github.io/img/thumbnails/nand2tetris_review.png</link>
				</image>
				<content type="html">
					
					<h1 id="what-is-nand2tetris">what is Nand2Tetris?</h1>
<p><a href="http://www.nand2tetris.org/">Nand2Tetris</a>, or <em>The Elements of Computing Systems</em>, is a twelve-part course in
fundamental computer engineering that steps you through the creation of a computer from the ground up, starting with
NAND logic gates and ending with an operating system capable of running a complicated program like Tetris.</p>

<p>The course, architected by <a href="http://www.cs.huji.ac.il/~noam/">Noam Nisan</a> and
<a href="http://shimonschocken.com/">Shimon Schocken</a>, is available as a
<a href="http://www.amazon.com/The-Elements-Computing-Systems-Principles/dp/0262640686">book</a> that you can
download for <a href="http://www1.idc.ac.il/tecs/plan.html">free</a> (though it appears that some chapters are only available in
terse PowerPoint form), and emphasizes a hands-on approach that leads up to some pretty epic struggles and <em>Aha!</em>
moments. I just recently finished the course after about two months of hacking on it in my free time – if you reliably
spend a couple hours a day on it, though, I can easily see you finishing in two weeks – and wanted to share an
overview of the content and some thoughts.</p>

<p><img src="http://files.konopoly.github.io/nand2tetris_review/book.png" alt="The cover of The Elements of Computing Systems." /></p>

<h1 id="content-overview">content overview</h1>

<div class="quote">
	Once upon a time, every computer specialist had a gestalt understanding of how computers worked. The overall
	interactions among hardware, software, compilers, and the operating system were simple and transparent enough to
	produce a coherent picture of the computer’s operations. As modern computer technologies have become increasingly
	more complex, this clarity is all but lost: the most fundamental ideas and techniques in computer science—the very
	essence of the field—are now hidden under many layers of obscure interfaces and proprietary implementations. An
	inevitable consequence of this complexity has been specialization, leading to computer science curricula of many
	courses, each covering a single aspect of the field.

	<div>
		Elements of Computing Systems: Preface
	</div>
</div>

<p><em>Nand2Tetris</em> consists of twelve lectures/chapters, each of which tackles a next logical step in building a computer
called “Hack,” and iterates on all of your work up to that point. Note that the book ships with various supplementary
materials (which you can download <a href="http://www.nand2tetris.org/software.php">here</a>), including emulators for various
components of the computer, like the hardware, stack, and virtual machine. Here’s an overview the ground you’ll cover:</p>

<p><img src="http://files.konopoly.github.io/nand2tetris_review/overview.png" alt="An overview of the Nand2Tetris pipeline." /></p>

<p>I’ll briefly summarize the contents of each chapter (partly as a review for myself).</p>

<h2 id="boolean-logic">1: boolean logic</h2>
<p>We learn about <a href="http://computer.howstuffworks.com/boolean.htm">boolean logic</a>, or logic with boolean values –
conveniently, <code>0</code>s and <code>1</code>s – that facilitate logical/mathematical operations in hardware. We then construct primitive
<a href="http://en.wikipedia.org/wiki/Logic_gate">logic gates</a>, like <code>AND</code>, <code>OR</code>, and <code>MUX</code>, which operate on single-bit
inputs, and chain those together to implement their multi-bit (in this case, the <em>Hack</em>
<a href="http://en.wikipedia.org/wiki/Word_%28computer_architecture%29">word</a>, or two bytes) counterparts, like <code>AND16</code>.</p>

<h2 id="boolean-arithmetic">2: boolean arithmetic</h2>
<p>We cover binary addition and <a href="http://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">two’s complement</a>, a means of
representing <em>signed</em> numbers (in other words, negative and positive values instead of positive values only), and
implement <em>adder</em> chips to perform addition at the hardware level. Finally, we devise an
<a href="http://www.computerhope.com/jargon/a/alu.htm">ALU</a> (<b>A</b>rithmetic <b>L</b>ogic <b>U</b>nit), which implements
addition and value comparisons (ie, logic operations), but, unlike industrial-grade hardware, <em>not</em> either of
multiplication and division.  We’ll implement those operations at the software level – specifically, in the operating
system’s math standard library – in the interest of simplicity, but at the expense of speed.</p>

<h2 id="sequential-logic">3: sequential logic</h2>
<p>Throughout chapters 1 and 2 we implemented <em>combinational</em> chips using <strong>NAND</strong> gates, and got
arithmetic/logic out of the way. This section introduces a new fundamental building block: the
<a href="http://hyperphysics.phy-astr.gsu.edu/hbase/electronic/dflipflop.html">DFF</a>, or <b>D</b>ata <b>F</b>lip <b>F</b>lop,
which will allow us to construct the second crucial component of our <em>Hack</em> computer – memory. Unlike <em>combinational</em>
chips, which simply intake arguments via input pins and “immediately” spit out a result to output pins and are thus
<em>stateless</em>, the <em>sequential</em> circuits that we’ll implement with flip-flops are capable of maintaining values across
time. Note that, even though we treat the <em>DFF</em> as a fundamental chip, it can be implemented <a href="http://en.wikipedia.org/wiki/Flip-flop_%28electronics%29#SR_NAND_latch">using NAND
gates</a> and more – Nand2Tetris just
thoughtfully spares us that gory implementation. We implement a <code>Bit</code>, <code>Register</code>, and multiple <code>RAM</code> chips with
iteratively larger capacities (64-word RAM consists of 8-word RAM, 512 of 64, etc.), and also a <em>program counter</em>,
which we’ll use to keep track of the next CPU instruction to execute. This <em>sequential</em> business is a little
mind-bending (and quite cool) because it effectively makes use of delayed recursion in a hardware context.</p>

<h2 id="machine-language">4: machine language</h2>
<p>We’re introduced to the <em>Hack</em> <a href="http://en.wikipedia.org/wiki/Machine_code">machine language</a>, or the format of the
binary strings that our CPU (to be implemented in the next chapter) will interpret as instructions, and its
correspondent <a href="http://en.wikipedia.org/wiki/Assembly_language">assembly language</a>: this is <em>the</em> interface between
hardware and software. Assembly is a human-readable representation of machine code which allows instructions to be
written with mnemonics like <code>ADD</code> or <code>SUB</code>; those are then compiled down to the appropriate binary by an <em>assembler</em>
(to be implemented in chapter 6) – essentially a glorified preprocessor. Here’s an example of <em>Hack</em> assembly:</p>

<div class="highlight"><pre><code class="language-text" data-lang="text">(LOOP)
	@END
	D;JEQ

	@sum
	M=M+D
	D=D-1

	@LOOP
	0;JMP</code></pre></div>

<p>The above code adds all consecutive integers between 0 and some number, storing the sum in a variable <code>sum</code>.</p>

<h2 id="computer-architecture">5: computer architecture</h2>
<p>We implement the <em>Hack</em> CPU, which abstracts away all hardware operations and exposes an API for executing them – that
is, the machine language. The CPU integrates chapters 2 (the <code>ALU</code>) and 3 (<code>RAM</code>) in a classic mold of the
<a href="http://www.teach-ict.com/as_as_computing/ocr/H447/F453/3_3_3/vonn_neuman/miniweb/pg3.htm">von Neumann</a> architecture:</p>

<p><img src="http://files.konopoly.github.io/nand2tetris_review/von_neumann.png" alt="A diagram of the von Neumann computer architecture." /></p>

<h2 id="assembler">6: assembler</h2>
<p>Assembly! Everyone loves assembly! This section extends chapter 4, which documented the <em>Hack</em> assembly language spec.,
and has you implement the assembler that translates such programs to binary machine instructions.</p>

<h2 id="virtual-machine">7, 8: virtual machine</h2>
<p>We learn about <em>virtual machines</em>, or <strong>platform-independent</strong> runtime environments that allow high-level languages to
compile down to a portable <a href="http://cs.lmu.edu/~ray/notes/ir/">intermediate representation</a>, or IR, (in this case, the
virtual machine language) that will run on any chip-set with an implementation of that virtual machine. Basically,
since different CPUs potentially have different machine languages, writing native compilers for high-level languages
would be a nightmare because the output binaries would have to be tweaked on a per-system basis. A virtual machine
handles that concern by itself exposing an interface – in the form of a virtual machine language, or IR – for
performing memory, logic, and math operations that target systems can reliably be expected to support.
Platform-specific compilers that convert the IR to assembly <em>do</em> have to be written, but that problem is now
centralized in one place; high-level language developers don’t have to worry about re-inventing the same compilation
wheel if they build their language around the same virtual machine, instead leaving that problem to the virtual machine
maintainers.</p>

<p><img src="http://files.konopoly.github.io/nand2tetris_review/virtual_machine.png" alt="A simple diagram of a virtual machine." /></p>

<p>Anyway, the <em>Hack</em> virtual machine wraps its assembly language in a simple, stack-based interface. We implement the
IR-to-assembly compiler, which becomes tricky once we involve things like stack frames. Sample code looks like:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">function</span> <span class="n">Point</span><span class="o">.</span><span class="n">new</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">constant</span> <span class="mi">2</span>
	<span class="n">call</span> <span class="n">Memory</span><span class="o">.</span><span class="n">alloc</span> <span class="mi">1</span>
	<span class="n">pop</span> <span class="n">pointer</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">argument</span> <span class="mi">0</span>
	<span class="n">pop</span> <span class="n">this</span> <span class="mi">0</span>
	<span class="n">push</span> <span class="n">argument</span> <span class="mi">1</span>
	<span class="n">pop</span> <span class="n">this</span> <span class="mi">1</span>
	<span class="n">push</span> <span class="n">pointer</span> <span class="mi">0</span>
	<span class="k">return</span></code></pre></div>

<h2 id="high-level-language">9: high-level language</h2>
<p>We’re introduced to the spec for a high-level, object-oriented language (without garbage collection) not unlike Java,
called <em>Jack</em>. The following <em>Jack</em> code defines a class <code>Point</code>, which represents a 2D geometric point:</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
	<span class="n">field</span> <span class="kt">int</span> <span class="n">_x</span><span class="o">,</span> <span class="n">_y</span><span class="o">;</span>

	<span class="n">constructor</span> <span class="n">Point</span> <span class="nf">new</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
		<span class="n">let</span> <span class="n">_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
		<span class="n">let</span> <span class="n">_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></div>

<h2 id="compiler">10, 11: compiler</h2>
<p>We implement a <em>Jack</em> compiler, which converts <em>Jack</em> programs to <em>Hack</em> virtual machine code. We learn about basic
compilation techniques – tokenization, recursive-descent parsers – and features – symbol tables, parse trees.</p>

<h2 id="operating-system">12: operating system</h2>
<p>Finally, we implement the <em>Hack</em> operating system (using <em>Jack</em>), which only consists of a number of standard system
libraries that govern things like math, memory management, and graphics. The chapter centers heavily on algorithms,
introducing some fascinating optimized approaches to problems including multiplication and heap allocation.</p>

<h1 id="review-and-advice">review and advice</h1>
<p>That was a pretty wild ride. I heard about <em>The Elements of Computing Systems</em> nearly two years ago and kept it on the
back-burner ever since, and am very glad I finally got around to reading it. Nisan and Schocken succeeded tremendously
in what they set out to accomplish – creating a course that gives you a universal, if shallow, understanding of
the entire hardware and software stack that computers operate on.</p>

<p>The individual sections are clear and concise, with just enough technical and academic background, examples, and
project walkthroughs, and benefit from a uniform structure. Each project assignment involves a good deal of
steering, as the authors underscore the <em>suggested</em> (though probably always the way you’d want to go anyway) approach to
implementing the next stage of the computer, but with nothing in the way of concrete implementations – this encourages
the reader to wet their feet and, in true hacker fashion, build the thing on their own. The software package that ships
with the course is entirely bug-free, and the emulators are both user-friendly and robust (these things are easy to
take for granted…).</p>

<p>An enormous amount of thought was clearly invested in the structure of the course. The various components of the <em>Hack</em>
system have perfectly coupled interrelationships, and your work up to any single point almost magically helps you
bootstrap the next project with incredible ease – this is mostly true for the hardware sections of the course, where
chip creation is a <em>highly</em> iterative process, and lets you create substantially complicated circuits out of nothing in
no time.</p>

<p>Another nice bit about Nand2Tetris is that it has much to offer to people at various skill levels. I entered the
course having never written a line of assembly, nor did I have much knowledge about compilers and virtual machines, but
I <em>did</em> have a reasonable amount of software engineering experience and at least a vague understanding of the
aforementioned components: the course ended up perfect, though I suspect that it’s mostly aimed at people in my
situation. Still, I can see it being useful even to greybeards with a nuanced knowledge of architectures, compilers,
and operating systems, simply because it does such a good job of tying them all together in a <em>single coherent
project</em>. I can imagine myself giving it another pass a couple of years from now, taking each of the projects further
and refreshing myself on the overview it provides.</p>

<p>Finally, the course is lightweight: the book comes in at just under 300 pages, and that’s with <em>twelve</em> sections that
collectively cover all of the vital components of a rudimentary computer. As a result, it doesn’t delve terribly far
into any one of them; you won’t implement many elementary chips, the authors intentionally skip over involved
problems like hardware multiplication, the computer won’t have a filesystem, you won’t come anywhere near hardware
acceleration, networking isn’t covered, and the high-level language you develop is highly limited (both in syntax and
functionality). That’s the point. <em>The Elements of Computing Systems</em> tries to provide a general introduction to each
component and a coherent project that ties them all together – it’s not the place to go for an immersive foray
into any of them. On the upside, it underscore a wealth of questions which you’re then encouraged to explore on your
own.</p>

<p>Taking some notes (<a href="https://github.com/sevko/portfolio/tree/develop/books/nand2tetris/notes">I did</a>) for future
reference might be a good idea while you read.</p>

<p>N2T is, in my opinion, a high quality must-read for software engineers. Can’t recommend it enough.</p>

<h2 id="a-note-on-requisites">a note on requisites</h2>
<p>This course is <em>not</em> for the amateur programmer. While the hardware chapters, the projects for which primarily consist
of implementing chips using an HDL, or hardware description language, don’t require any prior experience with anything,
the software sections involve the creation of reasonably complicated software in your programming language of choice. A
solid grasp of recursion is necessary for parsing, tokenization would probably be hell without a knowledge of regex,
and the compilers require some engineering acumen to implement cleanly – plus, it might be nice to have a vague
understanding of all the various components of a computer’s hardware and software going into the course, so that it
clarifies and refines your understanding of the various moving parts instead of simply introducing a bunch of
theretofore unheard-of concepts that, as a result, might be difficult to appreciate. I hope someone proves me wrong,
though!</p>

<h2 id="vim-syntax-files">vim syntax files</h2>
<p>As a complete aside, you’ll work with a number of ad-hoc languages throughout the course: <em>HDL</em>, <em>Hack</em> assembly,
<em>Hack</em> virtual machine language, and <em>Jack</em>. I’m a Vim user and got a little tired of the lack of syntax highlighting,
so wrote up a <a href="https://github.com/sevko/vim-nand2tetris-syntax">minimalist plugin</a> to provide it.</p>
>
				</content>
				<pubDate>Thu, 01 Jan 2015 13:00:00 -0800</pubDate>
				<link>http://konopoly.github.io/articles/nand-2-tetris</link>
				<guid isPermaLink="true">http://konopoly.github.io/articles/nand-2-tetris</guid>
			</item>
		
			<item>
				<title>prime number spirals</title>
				
					<category>math></category>
				
					<category>visualizations></category>
				
					<category>prime numbers></category>
				
					<category>javascript></category>
				
				<description>prime number spirals
Prime number spirals are visualizations of the distribution of prime numbers that underscore their frequent occurrences
along certain polynomials. They’re conceptually simple, yet create order out of the apparent chaos of primes and are
fairly beautiful. We’ll explore the Ulam and Sacks spirals, some of their underlying theory,
and algorithms to render each.

</description>
				<image>
					<url>http://www.w3schools.com/images/logo.gif</url>
					<title>An Ulam prime-number spiral.</title>
					<link>http://files.konopoly.github.io/img/thumbnails/prime_number_spiral.png</link>
				</image>
				<content type="html">
					
						<b>Warning:</b> this post contains math blocks rendered with the
						<a href="http://www.mathjax.org/">MathJax</a> JavaScript library. If you're using an RSS reader or
						otherwise have Javascript disabled, none of them will display, so you should instead read this article at
						its <a href="http://konopoly.github.io/articles/prime-number-spirals">source</a>.
					
					<h1 id="prime-number-spirals">prime number spirals</h1>
<p>Prime number spirals are visualizations of the distribution of prime numbers that underscore their frequent occurrences
along certain polynomials. They’re conceptually simple, yet create order out of the apparent chaos of primes and are
fairly beautiful. We’ll explore the Ulam and Sacks spirals, some of their underlying theory,
and algorithms to render each.</p>

<h2 id="ulam-spiral">Ulam spiral</h2>
<p>The story has it that <a href="http://en.wikipedia.org/wiki/Stanislaw_Ulam">Stanislaw Ulam</a>, a Polish-American mathematician of
<a href="http://en.wikipedia.org/wiki/Teller%E2%80%93Ulam_design">thermonuclear</a>
<a href="http://en.wikipedia.org/wiki/History_of_the_Teller%E2%80%93Ulam_design">fame</a><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, sat in a presentation of a
“long and very boring paper” at a 1963 scientific conference. After some time, he began doodling (the hallmark of great
genius), first writing out the first few positive integers in a counter-clockwise spiral, and then circling all of
the prime numbers. And he noticed something that he’d later formulate as “a strongly nonrandom appearance.” Even on
a small scale – say, the first 121 integers, which form a 11x11 grid – it’s visible that many primes align along
certain diagonal lines.</p>

<p><img src="http://files.konopoly.github.io/prime_number_spirals/small_ulam_spiral.png" alt="An Ulam spiral consisting of the first 121 natural numbers" /></p>

<p>Ulam later used <a href="http://en.wikipedia.org/wiki/MANIAC_II">MANIAC II</a>, a first-generation computer built for
<a href="http://en.wikipedia.org/wiki/Los_Alamos_Scientific_Laboratory">Los Alamos National Laboratory</a> in 1957, to generate
images of the first 65,000<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> integers. The following spiral contains the first 360,000
(600x600):</p>

<p><img src="http://files.konopoly.github.io/prime_number_spirals/big_ulam_spiral.png" alt="An Ulam spiral consisting of the first 360,000 natural numbers." /></p>

<p>Look closely, and we see much more than just white noise.</p>

<h2 id="sacks-spiral">Sacks spiral</h2>

<p>A software engineer named Robert Sacks devised a variant of the Ulam spiral in 1994. Unlike Ulam’s, Sacks’s spiral
distributes integers along an <a href="http://en.wikipedia.org/wiki/Archimedean_spiral">Archimedean spiral</a>, or a function of
the polar form <script type="math/tex">r = a + b\theta</script>. Sacks discarded <script type="math/tex">a</script> (which just controls the offset of the starting point of the curve
from the pole) and used <script type="math/tex">b=\frac{1}{2\pi}</script>, leaving <script type="math/tex">r = \frac{\theta}{2\pi}</script>; he then plotted the squares of all
the natural numbers – <script type="math/tex">{1, 4, 9, 16, 25, ...}</script> – on the intersections of the spiral and the polar axis, and filled
in the points between squares along the spiral, drawing them equidistant from one another.</p>

<p><img src="http://files.konopoly.github.io/prime_number_spirals/big_sacks_spiral.png" alt="A Sacks spiral consisting of the first 22,800 natural numbers." /></p>

<h1 id="prime-generating-polynomials">prime-generating polynomials</h1>

<p>The reason why we see ghostly diagonals is that some polynomials, informally called
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">prime-generating polynomials</a>, have aberrantly high
occurrences of prime numbers. <script type="math/tex">n^2 + n + 41</script>, for instance, patented by
<a href="http://en.wikipedia.org/wiki/Leonhard_Euler">Leonhard Euler</a> in 1772, is prime for all <script type="math/tex">n</script> in the range <script type="math/tex">[0, 39]</script>,
yielding <script type="math/tex">43, 47, 53, 61, ..., 1523, 1601</script>. A variant is <script type="math/tex">n^2 - n + 41</script>, proposed by
<a href="http://en.wikipedia.org/wiki/Adrien-Marie_Legendre">Adrien-Marie Legendre</a> in 1798, which is prime in <script type="math/tex">[0, 40]</script>.
Here are several others, as taken at random from
<a href="http://mathworld.wolfram.com/Prime-GeneratingPolynomial.html">Wolfram Mathworld</a>:</p>

<script type="math/tex; mode=display">\frac{1}{4}(n^5 - 133n^4 + 6729n^3 - 158379n^2 + 1720294n - 6823316)\\
\frac{1}{36}(n^6 - 126n^5 + 6217n^4 - 153066n^3 + 1987786n^2 - 13055316n + 34747236)\\
n^4 - 97n^3 + 3294n^2 - 45458n + 213589\\
n^5 - 99n^4 + 3588n^3 - 56822n^2 + 348272n - 286397</script>

<p>In the case of the rectangular Ulam spiral, these polynomials appear as diagonal lines. They were known about since
1772, if not earlier, and a prime-number spiral was hinted at twice before Ulam published his. In 1932 (31 years
earlier before Ulam!), <a href="http://en.wikipedia.org/wiki/Laurence_Monroe_Klauber">Laurence M. Klauber</a>, a herpetologist
primarily focused on the study of rattlesnakes, presented a method of using a spiral grid to identify prime-generating
polynomials to the
<a href="http://en.wikipedia.org/wiki/Mathematical_Association_of_America">Mathematical Association of America</a>. The second
frequently-cited mention of prime spirals came from <a href="http://en.wikipedia.org/wiki/Arthur_C._Clarke">Arthur C. Clarke</a>,
a British science-fiction writer, whose <a href="http://en.wikipedia.org/wiki/The_City_and_the_Stars"><em>The City and the Stars</em></a>
(1956) describes a protagonist, Jeserac, as “[setting] up the matrix of all possible integers, and [starting] his
computer stringing the primes across its surface as beads might be arranged at the intersections of a mesh.” In my
opinion, the second mention is fairly ambiguous, but the fact stands that, by the time Ulam published his famous
spiral, a general understanding of prime-generating polynomials existed and people were considering ways of visualizing
them. Thus, it’s perhaps a little disingenuous to suggest that he stumbled across it when “doodling” (something
intricate) at random – there may have been some method to it.</p>

<h1 id="rendering-the-spirals">rendering the spirals</h1>

<p>I was introduced to prime number spirals about a year ago, by <a href="https://www.youtube.com/watch?v=iFuR97YcSLM">a video</a>
on the excellent <a href="https://www.youtube.com/channel/UCoxcjq-8xIDTYp3uz647V5A">Numberphile</a>. I immediately jumped
into hacking together a Python script to render the spirals on my own, because it’s both tremendously easy and very
visually rewarding. I’ll revisit the implementation, this time in Javascript. I’m not going to show all of the
necessary code (like HTML markup/CSS styles) in the interest of brevity, but the zipped files are linked to at the end
of the post.</p>

<h2 id="canvas-setup">canvas setup</h2>

<p>Let’s outline our interface. We’ll define functions <code>ulamSpiral(numLayers)</code> and <code>sacksSpiral(numLayers)</code>, where
the argument <code>numLayers</code> is the number of revolutions in the spiral, or effectively the number of rings that it contains. Both
functions need to set the height and width of the canvas according to <code>numLayers</code>, and require a function
<code>drawPixel(x, y)</code> to plot pixels. Note that we’ll want <code>drawPixel()</code> to treat the <em>centroid</em> of the canvas as its
origin, so that <code>drawPixel(0, 0)</code> plots a point at its center and <em>not</em> the top-left corner. Because both the canvas
dimensions and the offset used by <code>drawPixel()</code> are dependent on <code>numLayers</code>, we’ll bundle them them into a function
called <code>setupCanvas()</code>.</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">sideLen</span> <span class="o">=</span> <span class="nx">numLayers</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">canvas</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;canvas&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>
	<span class="nx">canvas</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="nx">sideLen</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">getContext</span><span class="p">(</span><span class="s2">&quot;2d&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="kd">function</span> <span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">){</span>
		<span class="nx">context</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">numLayers</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">}</span></code></pre></div>

<p>Note that we set <code>sideLen</code> equal to <code>numLayers * 2 + 1</code>, rather than only <code>numLayers * 2</code>, because we need to account for the
row/column containing the origin of the spiral, which is not technically a ring. Now, we can use <code>setupCanvas()</code> to
both set the canvas dimensions, and return a <code>drawPixel()</code> that takes advantage of closure to access all of the
variables (<code>numLayers</code>, <code>context</code>) that it needs. Also, to draw a single pixel, we’re calling <code>fillRect()</code> with a
width and height of 1 – the canvas unfortunately doesn’t have (or perhaps just doesn’t expose) a single pixel-plotting
function. Finally, to test the primality of our values, we’ll use <a href="https://www.npmjs.org/~kenan">Kenan Yildirim</a>’s
<a href="https://www.npmjs.org/package/primality">primality</a> library, which provides <code>primality(val)</code>.</p>

<h2 id="ulam-algorithm">Ulam algorithm</h2>

<p>The dull stuff aside, we can begin implementing <code>ulamSpiral()</code>. The general algorithm will run as follows:</p>

<ol>
  <li>Use variables <code>x</code>, <code>y</code>, and <code>currValue</code> to track the position and value of the current point – the “head” of the
spiral.</li>
  <li>Trace out the square spirals by incrementing/decrementing <code>x</code> and <code>y</code>, while incrementing <code>currValue</code>.</li>
  <li>After the head of the spiral moves, if <code>currValue</code> is prime, plot a pixel at (<code>x</code>, <code>y</code>).</li>
</ol>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">ulamSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kd">function</span> <span class="nx">drawLine</span><span class="p">(</span><span class="nx">dx</span><span class="p">,</span> <span class="nx">dy</span><span class="p">,</span> <span class="nx">len</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">pixel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">pixel</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">pixel</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="nx">x</span> <span class="o">+=</span> <span class="nx">dx</span><span class="p">;</span>
			<span class="nx">y</span> <span class="o">+=</span> <span class="nx">dy</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">){</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span>
		<span class="nx">drawLine</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>We simply iterate <code>numLayers + 1</code> times, drawing rectangular layers – the spiral – as we go. I couldn’t think of a
better solution than using a function <code>drawLine()</code>, which accepts a direction (<code>dx</code> and <code>dy</code>, one of which should be
0), and a <code>length</code> to draw four different straight lines (perhaps it can somehow be done in one elegant loop?).</p>

<h2 id="sacks-algorithm">Sacks algorithm</h2>

<p>The Sacks spiral is a little more mathematically interesting because it relies (somewhat) on polar equations. Our
algorithm:</p>

<ol>
  <li>Iterate <code>numLayers</code> times.</li>
  <li>For each iteration, draw the values between the current square, <script type="math/tex">n ^ 2</script>, and the next, <script type="math/tex">n + 1 ^ 2</script>. Since
<script type="math/tex">(n + 1)^2 - n^2 = n^2 + 2n + 1 - n^2 = 2n + 1</script>, there are <script type="math/tex">2n + 1</script> points per iteration of <script type="math/tex">n</script>.</li>
  <li>Render each prime point by calculating its angle off the polar axis (the aligned squares), then its radius, or
distance from the pole, and then using trigonometry to solve for its cartesian coordinates.</li>
</ol>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">sacksSpiral</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">){</span>
	<span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

	<span class="kd">var</span> <span class="nx">drawPixel</span> <span class="o">=</span> <span class="nx">setupCanvas</span><span class="p">(</span><span class="nx">numLayers</span><span class="p">);</span>

	<span class="kd">var</span> <span class="nx">currValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">layer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span> <span class="o">&lt;=</span> <span class="nx">numLayers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span><span class="p">){</span>
		<span class="kd">var</span> <span class="nx">numPoints</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="kd">var</span> <span class="nx">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">point</span> <span class="o">&lt;=</span> <span class="nx">numPoints</span><span class="p">;</span> <span class="nx">point</span><span class="o">++</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="nx">primality</span><span class="p">(</span><span class="nx">currValue</span><span class="o">++</span><span class="p">)){</span>
				<span class="kd">var</span> <span class="nx">theta</span> <span class="o">=</span> <span class="nx">point</span> <span class="o">*</span> <span class="nx">angle</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">radius</span> <span class="o">=</span> <span class="nx">layer</span> <span class="o">+</span> <span class="nx">point</span> <span class="o">/</span> <span class="nx">numPoints</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">theta</span><span class="p">)</span> <span class="o">*</span> <span class="nx">radius</span><span class="p">;</span>
				<span class="nx">drawPixel</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">y</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>To calculate the polar angle of any point, we first solve for the angle between subsequent points
(<code>var angle = 2 * Math.PI / numPoints;</code>), and then multiply it by the fraction of the current rotation of the spiral
that the point lies at (<code>var theta = point * angle;</code>). We’ll also <code>Math.floor()</code> the coordinates sent to <code>drawPixel()</code>,
because, after the various trigonometic operations they’re likely decimals rather than integers and cause blurred
canvas reading.</p>

<p>That’s all! For more reading on prime-number spirals, I recommend this <a href="http://www.numberspiral.com/">in-depth article</a>
by Robert Sacks himself, and another <a href="http://www.dcs.gla.ac.uk/~jhw/spirals/">write-up</a> of algorithms used to render
them.</p>

<p>Download all of the source code <a href="http://files.konopoly.github.io/prime_number_spirals/prime_number_spirals.zip">here</a>, or view it
on <a href="https://github.com/sevko/portfolio/tree/develop/visualizations/prime_number_spirals">Github</a>.</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Ulam is also well-known for contributing to the
<a href="http://en.wikipedia.org/wiki/Manhattan_Project">Manhattan Project</a>, proponing the
<a href="http://en.wikipedia.org/wiki/Monte_Carlo_method">Monte Carlo method</a> of computation, and exploring
<a href="http://en.wikipedia.org/wiki/Project_Orion_(nuclear_propulsion)">spaceships propelled by nuclear explosions</a>,
amongst a large number of other things. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Assuming that Ulam began rendering his spiral with the integer 1 (instead of something like 41, which is also
common), I suspect that the generated images had exactly 65,025 integers. 65,000 integers implies as many pixels,
the square root – the Ulam spiral is inherently square – of which is 254.95, which obviously isn’t a valid image
height/width. Thus, we round to 255, and square for 65,025. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
>
				</content>
				<pubDate>Wed, 01 Oct 2014 14:00:00 -0700</pubDate>
				<link>http://konopoly.github.io/articles/prime-number-spirals</link>
				<guid isPermaLink="true">http://konopoly.github.io/articles/prime-number-spirals</guid>
			</item>
		
	</channel>
</rss>
